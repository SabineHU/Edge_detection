#pragma kernel EdgeDetectionDepth
#pragma kernel EdgeDetectionColor
#pragma kernel EdgeDetectionNormal
#pragma kernel EdgeDetectionCustom

#pragma kernel GaussianBlur

// Required for decompression
#include "UnityCG.cginc"

// Input buffers
Texture2D<float4> _CameraColorBuffer;
Texture2D<float4> _CameraDepthNormalsTexture;
Texture2D<float4> _BlurColorBuffer;

// Output buffer
RWTexture2D<float4> _EdgesBufferRW;
RWTexture2D<float4> _BlurBufferRW;

#define M_PI 3.14159

static float2 sobelPointsPositions[9] = {
    float2(-1,  1), float2(0,  1), float2(1,  1),
    float2(-1,  0), float2(0,  0), float2(1,  0),
    float2(-1, -1), float2(0, -1), float2(1, -1),
};

static float sobelXMatrix[9] = {
    1, 0, -1,
    2, 0, -2,
    1, 0, -1,
};

static float sobelYMatrix[9] = {
     1,  2,  1,
     0,  0,  0,
    -1, -2, -1,
};

float4 ComputeSobelFilter(Texture2D<float4> buffer, uint2 id, float threshold_min) {
    float4 g = float4(0.0, 0.0, 0.0, 0.0);

    float4 gx = float4(0.0, 0.0, 0.0, 0.0);
    float4 gy = float4(0.0, 0.0, 0.0, 0.0);

    for (int i = 0; i < 9; ++i) {
        const float4 color = buffer.Load(int3(id.xy + sobelPointsPositions[i], 0));

        float value = sobelXMatrix[i];
        gx += float4(value, value, value, value) * color;

        value = sobelYMatrix[i];
        gy += float4(value, value, value, value) * color;
    }

    g = sqrt(gx * gx + gy * gy);

    g.r = g.r < threshold_min ? 0.0 : g.r;
    g.g = g.g < threshold_min ? 0.0 : g.g;
    g.b = g.b < threshold_min ? 0.0 : g.b;
    g.a = g.a < threshold_min ? 0.0 : g.a;

    return g;
}

[numthreads(8, 8, 1)]
void EdgeDetectionDepth(uint3 id : SV_DispatchThreadID)
{
    const float threshold_min = 0.075;
    float4 g = ComputeSobelFilter(_CameraDepthNormalsTexture, id, threshold_min);

    _EdgesBufferRW[id.xy] = float4(g.zw, 0.0, 1.0);
}

[numthreads(8, 8, 1)]
void EdgeDetectionColor(uint3 id : SV_DispatchThreadID)
{
    //float width = 0.0;
    //float height = 0.0;
    //_EdgesBufferRW.GetDimensions(width, height);
    //_EdgesBufferRW[id.xy] = float4(id.x / width, id.y / height, 0.0, 1.0);

    const float threshold_min = 0.075;
    const float4 g = ComputeSobelFilter(_BlurColorBuffer, id, threshold_min);

    _EdgesBufferRW[id.xy] = float4(g.rgb, 1.0);
}

[numthreads(8, 8, 1)]
void EdgeDetectionNormal(uint3 id : SV_DispatchThreadID)
{
    const float threshold_min = 0.25;
    const float4 g = ComputeSobelFilter(_CameraDepthNormalsTexture, id, threshold_min);

    _EdgesBufferRW[id.xy] = float4(g.xy, 0.0, 1.0);
}

[numthreads(8, 8, 1)]
void EdgeDetectionCustom(uint3 id : SV_DispatchThreadID)
{
	float4 colorBuffer = _CameraColorBuffer.Load(int3(id.xy, 0));
	float4 depthNormal = _CameraDepthNormalsTexture.Load(int3(id.xy, 0));

    float4 blur = float4(0.0, 0.0, 0.0, 0.0);
    const float weight[7] = { 0.09, 0.11, 0.18, 0.24, 0.18, 0.11, 0.09 };

    for (int i = 0, j = -3; i < 5; ++i, ++j) {
        blur += ComputeSobelFilter(_BlurColorBuffer, id + float2(j, 0.0), 0.25) * weight[i];
        blur += ComputeSobelFilter(_BlurColorBuffer, id - float2(j, 0.0), 0.25) * weight[i];
        blur += ComputeSobelFilter(_BlurColorBuffer, id + float2(0.0, j), 0.25) * weight[i];
        blur += ComputeSobelFilter(_BlurColorBuffer, id - float2(0.0, j), 0.25) * weight[i];
    }

    float4 depth = ComputeSobelFilter(_CameraDepthNormalsTexture, id, 0.075);
    float4 color = ComputeSobelFilter(_CameraColorBuffer, id, 0.075);

    float threshold = 0.2;
    if (depth.x < threshold)
        depth.x = 0.0;
    if (depth.y < threshold)
        depth.y = 0.0;

    float3 res = (blur.rgb + ceil(blur.rgb + color.rgb)) * colorBuffer.rgb;
    //res = min(depth.ggg + depth.rrr, 1.0) * res;

	_EdgesBufferRW[id.xy] = float4(colorBuffer.xyz * 0.5 + depthNormal.xyy * 0.5f, 1.0);
    _EdgesBufferRW[id.xy] = float4(res, 1.0);
}

static float blurMatrix[25] = {
    2,  4,  5,  4, 2,
    4,  9, 12,  9, 4,
    5, 12, 15, 12, 5,
    4,  9, 12,  9, 4,
    2,  4,  5,  4, 2,
};

float3 ComputeGaussianBlur(Texture2D<float4> buffer, uint2 id) {
    float3 blur = float3(0.0, 0.0, 0.0);

    int2 idx = int2(-2, 2);
    for (int i = 0; i < 25; ++i) {
        const float3 color = buffer.Load(int3(id.xy + idx, 0)).rgb;

        const float value = blurMatrix[i];
        blur += float3(value, value, value) * color;

        idx.x += 1;
        if (idx.x == 3) {
            idx.x = -2;
            idx.y -= 1;
        }
    }

    blur /= 159.0;
    return blur;
}

[numthreads(8, 8, 1)]
void GaussianBlur(uint3 id : SV_DispatchThreadID)
{
    float3 blur = ComputeGaussianBlur(_CameraColorBuffer, id.xy);
    _BlurBufferRW[id.xy] = float4(blur, 1.0);
}
