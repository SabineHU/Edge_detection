#pragma kernel EdgeDetectionDepth
#pragma kernel EdgeDetectionColor
#pragma kernel EdgeDetectionNormal
#pragma kernel EdgeDetectionCustom

// Required for decompression
#include "UnityCG.cginc"

// Input buffers
Texture2D<float4> _CameraColorBuffer;
Texture2D<float4> _CameraDepthNormalsTexture;

// Output buffer
RWTexture2D<float4> _EdgesBufferRW;

#define M_PI 3.14159

static float2 sobelPointsPositions[9] = {
    float2(-1,  1), float2(0,  1), float2(1,  1),
    float2(-1,  0), float2(0,  0), float2(1,  0),
    float2(-1, -1), float2(0, -1), float2(1, -1),
};

static float sobelXMatrix[9] = {
    1, 0, -1,
    2, 0, -2,
    1, 0, -1,
};

static float sobelYMatrix[9] = {
     1,  2,  1,
     0,  0,  0,
    -1, -2, -1,
};

struct SobelFilterImage {
    float3 g;
    float3 theta;
};

SobelFilterImage ComputeSobelFilter(uint2 id) {
    SobelFilterImage sobelImage;
    sobelImage.g = float3(0.0, 0.0, 0.0);

    float3 gx = float3(0.0, 0.0, 0.0);
    float3 gy = float3(0.0, 0.0, 0.0);

    for (int i = 0; i < 9; ++i) {
        float3 color = _CameraColorBuffer.Load(int3(id.xy + sobelPointsPositions[i], 0)).r;
        gx.r += sobelXMatrix[i] * color;
        gy.r += sobelYMatrix[i] * color;

        color = _CameraColorBuffer.Load(int3(id.xy + sobelPointsPositions[i], 0)).g;
        gx.g += sobelXMatrix[i] * color;
        gy.g += sobelYMatrix[i] * color;

        color = _CameraColorBuffer.Load(int3(id.xy + sobelPointsPositions[i], 0)).b;
        gx.b += sobelXMatrix[i] * color;
        gy.b += sobelYMatrix[i] * color;
    }

    sobelImage.g.r = sqrt(gx.r * gx.r + gy.r * gy.r);
    sobelImage.g.g = sqrt(gx.g * gx.g + gy.g * gy.g);
    sobelImage.g.b = sqrt(gx.b * gx.b + gy.b * gy.b);

    return sobelImage;
}

[numthreads(8, 8, 1)]
void EdgeDetectionDepth(uint3 id : SV_DispatchThreadID)
{
	float4 depthNormal = _CameraDepthNormalsTexture.Load(int3(id.xy, 0));
	_EdgesBufferRW[id.xy] = float4(depthNormal.zw, 0.0, 1.0);
}

[numthreads(8, 8, 1)]
void EdgeDetectionColor(uint3 id : SV_DispatchThreadID)
{
	float4 colorBuffer = _CameraColorBuffer.Load(int3(id.xy, 0));
    //float width = 0.0;
    //float height = 0.0;
    //_EdgesBufferRW.GetDimensions(width, height);
	//_EdgesBufferRW[id.xy] = float4(id.x / width, id.y / height, 0.0, 1.0);

	//_EdgesBufferRW[id.xy] = float4(colorBuffer.xyz * float3(1.0, 0.8, 0.5), 1.0);

    SobelFilterImage sobelImage = ComputeSobelFilter(id);

    const float threshold_min = 0.075;

    sobelImage.g.r = sobelImage.g.r < threshold_min ? 0.0 : sobelImage.g.r;
    sobelImage.g.g = sobelImage.g.g < threshold_min ? 0.0 : sobelImage.g.g;
    sobelImage.g.b = sobelImage.g.b < threshold_min ? 0.0 : sobelImage.g.b;

	_EdgesBufferRW[id.xy] = float4(sobelImage.g.r, sobelImage.g.g, sobelImage.g.b, 1.0);
}

[numthreads(8, 8, 1)]
void EdgeDetectionNormal(uint3 id : SV_DispatchThreadID)
{
	float4 depthNormal = _CameraDepthNormalsTexture.Load(int3(id.xy, 0));
	_EdgesBufferRW[id.xy] = float4(depthNormal.xy, 0.0, 1.0);
}

[numthreads(8, 8, 1)]
void EdgeDetectionCustom(uint3 id : SV_DispatchThreadID)
{
	float4 colorBuffer = _CameraColorBuffer.Load(int3(id.xy, 0));
	float4 depthNormal = _CameraDepthNormalsTexture.Load(int3(id.xy, 0));
	_EdgesBufferRW[id.xy] = float4(colorBuffer.xyz * 0.5 + depthNormal.xyy * 0.5f, 1.0);
}
